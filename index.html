<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>電光狐狸：霓虹快跑</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #1a1a2e;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: 'Courier New', Courier, monospace;
            color: white;
            overflow: hidden;
        }
        #gameContainer {
            position: relative;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.2);
            border: 4px solid #333;
        }
        canvas {
            display: block;
            background-color: #0f0f1a;
        }
        #ui-layer {
            position: absolute;
            top: 10px;
            left: 10px;
            font-size: 20px;
            font-weight: bold;
            text-shadow: 2px 2px #000;
            pointer-events: none;
        }
        #overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            display: none; /* Initially hidden */
        }
        h1 { color: #ff9f43; margin-bottom: 10px; text-transform: uppercase; }
        p { color: #ccc; margin-bottom: 20px; }
        button {
            padding: 10px 20px;
            font-size: 18px;
            background: #0abde3;
            border: none;
            color: #fff;
            cursor: pointer;
            border-radius: 5px;
            transition: background 0.3s;
        }
        button:hover { background: #00d2d3; }
        .instruction { font-size: 14px; color: #aaa; margin-top: 15px; }
    </style>
</head>
<body>

<div id="gameContainer">
    <canvas id="gameCanvas" width="800" height="450"></canvas>
    <div id="ui-layer">HP: <span id="hpDisplay">3</span> | Score: <span id="scoreDisplay">0</span></div>
    
    <div id="overlay" style="display: flex;">
        <h1 id="titleText">Cyber-Fox: Neon Run</h1>
        <p id="subText">Help Sparky reach the portal!</p>
        <button onclick="startGame()">START GAME</button>
        <div class="instruction">
            ← → : 移動 | Space/↑ : 跳躍 (可二段跳)<br>
            Shift / Z : 電光衝刺 (攻擊與加速)
        </div>
    </div>
</div>

<script>
/**
 * 核心遊戲引擎
 */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// 遊戲狀態
let gameState = 'MENU'; // MENU, PLAYING, GAMEOVER, WIN
let animationId;
let score = 0;

// 攝影機
const camera = { x: 0, y: 0 };

// 輸入控制
const keys = {
    right: false,
    left: false,
    up: false,
    dash: false
};

// 物理常數
const GRAVITY = 0.6;
const FRICTION = 0.8;
const SPEED = 5;
const JUMP_FORCE = -12;
const DASH_SPEED = 15;

// 遊戲物件列表
let platforms = [];
let enemies = [];
let particles = [];
let portal = {};

// 主角類別
class Player {
    constructor() {
        this.width = 30;
        this.height = 30;
        this.x = 100;
        this.y = 300;
        this.velX = 0;
        this.velY = 0;
        this.color = '#ff9f43'; // Fox Orange
        this.jumpCount = 0;
        this.maxJumps = 2;
        this.hp = 3;
        this.isDashing = false;
        this.dashTimer = 0;
        this.dashCooldown = 0;
        this.invincible = 0;
        this.facingRight = true;
    }

    update() {
        // 移動邏輯
        if (this.isDashing) {
            this.velX = this.facingRight ? DASH_SPEED : -DASH_SPEED;
            this.velY = 0; // 衝刺時不受重力影響
            this.dashTimer--;
            createParticle(this.x + this.width/2, this.y + this.height/2, '#0abde3', 2);
            if (this.dashTimer <= 0) this.isDashing = false;
        } else {
            // 普通移動
            if (keys.right) {
                if (this.velX < SPEED) this.velX++;
                this.facingRight = true;
            }
            if (keys.left) {
                if (this.velX > -SPEED) this.velX--;
                this.facingRight = false;
            }

            // 摩擦力
            this.velX *= FRICTION;
            
            // 重力
            this.velY += GRAVITY;
        }

        // 位置更新
        this.x += this.velX;
        this.y += this.velY;

        // 衝刺冷卻與無敵時間
        if (this.dashCooldown > 0) this.dashCooldown--;
        if (this.invincible > 0) this.invincible--;

        // 地圖邊界 (掉落判定)
        if (this.y > canvas.height + 200) {
            this.hp = 0;
        }

        // 碰撞檢測
        this.checkPlatformCollisions();
        this.checkEnemyCollisions();
        this.checkPortal();
    }

    draw() {
        ctx.save();
        // 無敵閃爍效果
        if (this.invincible > 0 && Math.floor(Date.now() / 50) % 2 === 0) {
            ctx.globalAlpha = 0.5;
        }

        // 繪製身體 (狐狸)
        ctx.fillStyle = this.isDashing ? '#0abde3' : this.color;
        ctx.fillRect(this.x - camera.x, this.y, this.width, this.height);
        
        // 繪製護目鏡
        ctx.fillStyle = '#00d2d3';
        let eyeX = this.facingRight ? this.x + 18 : this.x + 2;
        ctx.fillRect(eyeX - camera.x, this.y + 5, 10, 5);

        // 耳朵
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.moveTo(this.x - camera.x + 5, this.y);
        ctx.lineTo(this.x - camera.x + 10, this.y - 10);
        ctx.lineTo(this.x - camera.x + 15, this.y);
        ctx.fill();
        
        ctx.beginPath();
        ctx.moveTo(this.x - camera.x + 15, this.y);
        ctx.lineTo(this.x - camera.x + 20, this.y - 10);
        ctx.lineTo(this.x - camera.x + 25, this.y);
        ctx.fill();

        ctx.restore();
    }

    jump() {
        if (this.jumpCount < this.maxJumps) {
            this.velY = JUMP_FORCE;
            this.jumpCount++;
            createParticle(this.x + 15, this.y + 30, '#fff', 5);
        }
    }

    dash() {
        if (this.dashCooldown <= 0 && !this.isDashing) {
            this.isDashing = true;
            this.dashTimer = 10; // 衝刺持續幀數
            this.dashCooldown = 60; // 冷卻時間
            // 衝刺時稍微向上提，避免卡地板
            this.velY = -2;
        }
    }

    checkPlatformCollisions() {
        platforms.forEach(p => {
            // 簡單的 AABB 碰撞 (只處理從上方落下的情況以簡化原型)
            if (
                this.x < p.x + p.w &&
                this.x + this.width > p.x &&
                this.y + this.height > p.y &&
                this.y + this.height < p.y + p.h + 20 && // 防止從下方穿過時被吸上去
                this.velY >= 0
            ) {
                this.isDashing = false;
                this.y = p.y - this.height;
                this.velY = 0;
                this.jumpCount = 0;
            }
        });
    }

    checkEnemyCollisions() {
        enemies.forEach((e, index) => {
            if (e.dead) return;
            
            if (
                this.x < e.x + e.w &&
                this.x + this.width > e.x &&
                this.y < e.y + e.h &&
                this.y + this.height > e.y
            ) {
                // 判定：踩踏 (玩家在敵人上方且正在下落)
                const hitFromAbove = (this.y + this.height) - (e.y + e.h/2) < 10 && this.velY > 0;

                if (hitFromAbove) {
                    // 踩死敵人
                    e.die();
                    this.velY = JUMP_FORCE * 0.8; // 反彈
                    score += 100;
                } else if (this.isDashing) {
                    // 衝刺撞死敵人
                    e.die();
                    score += 100;
                } else {
                    // 受傷
                    if (this.invincible <= 0) {
                        this.hp--;
                        this.invincible = 60;
                        this.velY = -5;
                        this.velX = this.x < e.x ? -10 : 10; // 被擊退
                    }
                }
            }
        });
    }

    checkPortal() {
        if (
            this.x < portal.x + portal.w &&
            this.x + this.width > portal.x &&
            this.y < portal.y + portal.h &&
            this.y + this.height > portal.y
        ) {
            gameOver(true);
        }
    }
}

// 敵人類別
class Enemy {
    constructor(x, y, range) {
        this.x = x;
        this.y = y;
        this.startX = x;
        this.w = 30;
        this.h = 30;
        this.range = range; // 巡邏範圍
        this.speed = 2;
        this.dir = 1;
        this.dead = false;
    }

    update() {
        if (this.dead) return;
        
        this.x += this.speed * this.dir;
        
        // 巡邏邏輯
        if (this.x > this.startX + this.range || this.x < this.startX) {
            this.dir *= -1;
        }
    }

    draw() {
        if (this.dead) return;
        
        // 繪製敵人 (紅色機器蟲)
        ctx.fillStyle = '#ff4757';
        ctx.fillRect(this.x - camera.x, this.y, this.w, this.h);
        
        // 眼睛
        ctx.fillStyle = '#000';
        ctx.fillRect(this.x - camera.x + 5, this.y + 5, 20, 5);
        
        // 腳
        ctx.strokeStyle = '#aaa';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(this.x - camera.x + 5, this.y + this.h);
        ctx.lineTo(this.x - camera.x, this.y + this.h + 5);
        ctx.stroke();
    }

    die() {
        this.dead = true;
        createParticle(this.x + this.w/2, this.y + this.h/2, '#ff4757', 10);
    }
}

// 粒子效果 (爆炸/灰塵)
class Particle {
    constructor(x, y, color) {
        this.x = x;
        this.y = y;
        this.color = color;
        this.size = Math.random() * 5 + 2;
        this.velX = (Math.random() - 0.5) * 5;
        this.velY = (Math.random() - 0.5) * 5;
        this.life = 30;
    }
    update() {
        this.x += this.velX;
        this.y += this.velY;
        this.life--;
        this.size *= 0.9;
    }
    draw() {
        ctx.fillStyle = this.color;
        ctx.fillRect(this.x - camera.x, this.y, this.size, this.size);
    }
}

function createParticle(x, y, color, count) {
    for(let i=0; i<count; i++) {
        particles.push(new Particle(x, y, color));
    }
}

// 關卡生成
function initLevel() {
    platforms = [];
    enemies = [];
    
    // 地板與平台佈局 (x, y, w, h)
    const layout = [
        // 起點區
        {x: 0, y: 400, w: 800, h: 50},
        // 第一個跳躍
        {x: 900, y: 350, w: 200, h: 50},
        // 高台
        {x: 1200, y: 250, w: 150, h: 50},
        {x: 1450, y: 180, w: 150, h: 50},
        // 充滿敵人的長廊
        {x: 1700, y: 400, w: 800, h: 50},
        // 最後的階梯
        {x: 2600, y: 350, w: 100, h: 20},
        {x: 2800, y: 300, w: 100, h: 20},
        {x: 3000, y: 400, w: 400, h: 50}, // 終點平台
    ];

    layout.forEach(block => platforms.push(block));

    // 生成敵人
    enemies.push(new Enemy(400, 370, 200));
    enemies.push(new Enemy(1750, 370, 150));
    enemies.push(new Enemy(2000, 370, 150));
    enemies.push(new Enemy(2300, 370, 100));

    // 終點傳送門
    portal = { x: 3200, y: 300, w: 50, h: 100 };
}

let player;

// 遊戲主循環
function loop() {
    if (gameState !== 'PLAYING') return;

    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // 背景視差 (簡單移動)
    ctx.fillStyle = '#222';
    ctx.fillRect(100 - camera.x * 0.5, 100, 50, 200); // 假裝是背景建築

    // 更新玩家
    player.update();
    
    // 相機跟隨
    camera.x = player.x - 200;
    // 限制相機不要超出左邊界
    if (camera.x < 0) camera.x = 0;

    // 繪製與更新平台
    ctx.fillStyle = '#5f27cd'; // Neon Purple Platform
    platforms.forEach(p => {
        // 只繪製畫面內的平台
        if (p.x - camera.x < canvas.width && p.x + p.w - camera.x > 0) {
            ctx.fillRect(p.x - camera.x, p.y, p.w, p.h);
            // 平台邊框
            ctx.strokeStyle = '#a29bfe';
            ctx.strokeRect(p.x - camera.x, p.y, p.w, p.h);
        }
    });

    // 繪製與更新敵人
    enemies.forEach(e => {
        e.update();
        e.draw();
    });

    // 繪製與更新粒子
    particles = particles.filter(p => p.life > 0);
    particles.forEach(p => {
        p.update();
        p.draw();
    });

    player.draw();

    // 繪製傳送門
    ctx.fillStyle = '#009432';
    ctx.fillRect(portal.x - camera.x, portal.y, portal.w, portal.h);
    // 傳送門特效
    ctx.fillStyle = `rgba(0, 255, 0, ${Math.random()})`;
    ctx.fillRect(portal.x - camera.x + 10, portal.y + 10, portal.w - 20, portal.h - 20);

    // UI 更新
    document.getElementById('hpDisplay').innerText = player.hp;
    document.getElementById('scoreDisplay').innerText = score;

    // 檢查死亡
    if (player.hp <= 0) {
        gameOver(false);
    }

    animationId = requestAnimationFrame(loop);
}

// 遊戲控制邏輯
function startGame() {
    document.getElementById('overlay').style.display = 'none';
    initLevel();
    player = new Player();
    score = 0;
    gameState = 'PLAYING';
    loop();
}

function gameOver(win) {
    gameState = win ? 'WIN' : 'GAMEOVER';
    cancelAnimationFrame(animationId);
    const overlay = document.getElementById('overlay');
    const title = document.getElementById('titleText');
    const sub = document.getElementById('subText');
    
    overlay.style.display = 'flex';
    if (win) {
        title.innerText = "MISSION COMPLETE!";
        title.style.color = "#009432";
        sub.innerText = `Final Score: ${score}`;
    } else {
        title.innerText = "GAME OVER";
        title.style.color = "#e74c3c";
        sub.innerText = "Sparky malfunctioned.";
    }
}

// 鍵盤監聽
window.addEventListener('keydown', e => {
    if (e.code === 'ArrowRight') keys.right = true;
    if (e.code === 'ArrowLeft') keys.left = true;
    if (e.code === 'ArrowUp' || e.code === 'Space') {
        if (gameState === 'PLAYING') player.jump();
    }
    if (e.code === 'ShiftLeft' || e.code === 'KeyZ') {
        if (gameState === 'PLAYING') player.dash();
    }
});

window.addEventListener('keyup', e => {
    if (e.code === 'ArrowRight') keys.right = false;
    if (e.code === 'ArrowLeft') keys.left = false;
});

</script>
</body>
</html>
