<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FocusType: Ranked Ladder</title>
    <style>
        :root {
            --bg-color: #f0f2f5;
            --card-bg: #ffffff;
            --text-main: #1f2937;
            --text-sub: #6b7280;
            --highlight: #3b82f6;
            --correct: #10b981;
            --error: #ef4444;
            
            /* Rank Colors */
            --bronze: #cd7f32;
            --silver: #94a3b8;
            --gold: #f59e0b;
            --platinum: #06b6d4;
            --diamond: #8b5cf6;
        }

        * { box-sizing: border-box; }

        body {
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-main);
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
        }

        /* Header & Rank Info */
        .header-section {
            text-align: center;
            margin-bottom: 20px;
            width: 100%;
            max-width: 900px;
        }

        .rank-badge-container {
            background: var(--card-bg);
            padding: 15px 30px;
            border-radius: 50px;
            display: inline-flex;
            align-items: center;
            gap: 15px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.08);
            margin-top: 10px;
        }

        .rank-icon {
            width: 40px; height: 40px;
            border-radius: 50%;
            background: #ccc;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: white;
            font-size: 1.2rem;
        }

        .rank-info {
            text-align: left;
            display: flex;
            flex-direction: column;
        }

        .rank-title { font-weight: 800; font-size: 1.1rem; text-transform: uppercase; letter-spacing: 1px; }
        .rank-points { font-size: 0.9rem; color: var(--text-sub); }

        /* Race Track */
        .race-track {
            background: var(--card-bg);
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.05);
            width: 100%;
            max-width: 900px;
            margin-bottom: 20px;
        }

        .race-lane {
            display: flex;
            align-items: center;
            margin-bottom: 12px;
        }
        .race-lane:last-child { margin-bottom: 0; }

        .lane-label {
            width: 100px;
            font-size: 0.8rem;
            font-weight: bold;
            text-align: right;
            margin-right: 15px;
            color: var(--text-sub);
        }
        
        .lane-bar-bg {
            flex-grow: 1;
            height: 10px;
            background-color: #e5e7eb;
            border-radius: 5px;
            overflow: hidden;
        }

        .lane-progress {
            height: 100%;
            width: 0%;
            border-radius: 5px;
            transition: width 0.3s ease-out;
        }

        /* Colors for Bots */
        .lane-user .lane-progress { background-color: var(--highlight); }
        .lane-bot1 .lane-progress { background-color: #ef4444; } /* Rival Red */
        .lane-bot2 .lane-progress { background-color: #f59e0b; } /* Rival Orange */
        .lane-bot3 .lane-progress { background-color: #8b5cf6; } /* Rival Purple */

        .lane-user .lane-label { color: var(--highlight); font-weight: 900; font-size: 0.9rem;}

        /* Typing Area */
        .typing-area {
            background: var(--card-bg);
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.05);
            text-align: center;
            position: relative;
            width: 100%;
            max-width: 900px;
        }

        .live-stats {
            display: flex; justify-content: space-between; margin-bottom: 15px;
            font-size: 0.9rem; color: var(--text-sub); font-weight: bold;
        }

        .word-box {
            height: 130px;
            overflow: hidden;
            border: 2px solid #e5e7eb;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
            display: flex; flex-wrap: wrap; align-content: flex-start;
            line-height: 2.5rem;
            font-family: 'Courier New', Courier, monospace;
            font-size: 1.4rem;
            background: #fafafa;
            cursor: text;
        }

        .word { margin-right: 12px; padding: 2px 5px; border-radius: 4px; color: #9ca3af; }
        .word.active { background-color: #e0e7ff; color: var(--text-main); border-bottom: 2px solid var(--highlight); }
        .word.correct { color: var(--correct); }
        .word.incorrect { color: var(--error); text-decoration: line-through; }

        input#type-input {
            width: 100%; padding: 15px; font-size: 1.2rem;
            border: 2px solid #d1d5db; border-radius: 8px; outline: none;
            font-family: 'Courier New', Courier, monospace;
            transition: border-color 0.2s;
        }
        input#type-input:focus { border-color: var(--highlight); }
        input#type-input.input-error { background-color: #fef2f2; border-color: var(--error); }

        /* Results Modal */
        .modal-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(255,255,255,0.98);
            border-radius: 12px;
            display: none;
            flex-direction: column; align-items: center; justify-content: center;
            z-index: 10;
        }
        .modal-overlay.visible { display: flex; }

        .result-title { font-size: 2.2rem; font-weight: 800; margin-bottom: 5px; }
        .result-sub { color: var(--text-sub); margin-bottom: 20px; }

        .rp-change {
            font-size: 3rem; font-weight: 900;
            margin: 10px 0;
            text-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .rp-plus { color: var(--correct); }
        .rp-minus { color: var(--error); }

        .stats-row { display: flex; gap: 20px; margin-bottom: 20px; }
        .stat-mini { text-align: center; }
        .stat-mini span { display: block; font-weight: bold; font-size: 1.2rem; }
        .stat-mini label { font-size: 0.75rem; color: var(--text-sub); text-transform: uppercase; }

        button.btn-primary {
            background-color: var(--highlight); color: white; border: none;
            padding: 12px 30px; font-size: 1rem; border-radius: 6px;
            cursor: pointer; font-weight: bold; transition: background 0.2s;
        }
        button.btn-primary:hover { background-color: #2563eb; }

        /* Reset Button for Debug */
        .btn-reset {
            margin-top: 20px; font-size: 0.8rem; color: #999; background: none; border: none; cursor: pointer; text-decoration: underline;
        }

    </style>
</head>
<body>

    <div class="header-section">
        <h1>FocusType <span style="color:var(--highlight)">Ranked</span></h1>
        <div class="rank-badge-container" id="rank-display">
            <div class="rank-icon" id="rank-icon">-</div>
            <div class="rank-info">
                <div class="rank-title" id="rank-name">Placement</div>
                <div class="rank-points" id="rank-details">Play 1 game to calibrate</div>
            </div>
        </div>
    </div>

    <div class="race-track">
        <div class="race-lane lane-user">
            <div class="lane-label">YOU</div>
            <div class="lane-bar-bg"><div class="lane-progress" id="prog-user" style="width: 0%"></div></div>
        </div>
        <div class="race-lane lane-bot1">
            <div class="lane-label" id="label-bot1">Bot 1</div>
            <div class="lane-bar-bg"><div class="lane-progress" id="prog-bot1" style="width: 0%"></div></div>
        </div>
        <div class="race-lane lane-bot2">
            <div class="lane-label" id="label-bot2">Bot 2</div>
            <div class="lane-bar-bg"><div class="lane-progress" id="prog-bot2" style="width: 0%"></div></div>
        </div>
        <div class="race-lane lane-bot3">
            <div class="lane-label" id="label-bot3">Bot 3</div>
            <div class="lane-bar-bg"><div class="lane-progress" id="prog-bot3" style="width: 0%"></div></div>
        </div>
    </div>

    <div class="typing-area">
        <div class="live-stats">
            <span id="progress-text">0 / 40</span>
            <span id="timer-text">00:00</span>
        </div>

        <div class="word-box" id="word-box" onclick="document.getElementById('type-input').focus()"></div>

        <input type="text" id="type-input" placeholder="Type the words here..." autocomplete="off" spellcheck="false">

        <div id="results-modal" class="modal-overlay">
            <div class="result-title" id="res-title">Finished!</div>
            <div class="result-sub" id="res-sub">Calculating rank update...</div>
            
            <div class="rp-change" id="res-rp-change"></div>

            <div class="stats-row">
                <div class="stat-mini">
                    <span id="res-wpm">0</span> <label>WPM</label>
                </div>
                <div class="stat-mini">
                    <span id="res-acc">0%</span> <label>Accuracy</label>
                </div>
                <div class="stat-mini">
                    <span id="res-rank">#</span> <label>Place</label>
                </div>
            </div>

            <button class="btn-primary" onclick="initGame()">Next Match</button>
        </div>
    </div>

    <button class="btn-reset" onclick="resetData()">[Reset Progress & Data]</button>

    <script>
        // --- 1. Configuration ---
        const SESSION_LENGTH = 40;
        const wordPool = [
            "really", "family", "school", "always", "result", "change", "reason", "person", "moment", "father",
            "report", "course", "mother", "period", "center", "figure", "system", "better", "minute", "friend",
            "street", "letter", "within", "market", "record", "effect", "action", "police", "office", "matter",
            "health", "myself", "ground", "expect", "strong", "common", "series", "amount", "growth", "answer",
            "leader", "energy", "public", "remain", "policy", "theory", "detail", "design", "player", "little",
            "people", "should", "before", "number", "follow", "create", "happen", "during", "appear", "travel",
            "future", "simple", "summer", "winter", "season", "spring", "dinner", "doctor", "sister", "animal",
            "listen", "charge", "member", "memory", "method", "camera", "weight", "window", "writer", "yellow",
            "garden", "global", "manage", "notice", "object", "option", "orange", "parent", "party", "reduce",
            "because", "through", "between", "student", "country", "another", "program", "problem", "service", "against",
            "company", "provide", "however", "develop", "without", "general", "present", "council", "example", "already",
            "process", "suggest", "support", "control", "whether", "product", "history", "himself", "believe", "subject",
            "receive", "quality", "special", "picture", "college", "certain", "teacher", "perhaps", "society", "morning",
            "private", "include", "section", "several", "project", "nothing", "measure", "message", "benefit", "account",
            "century", "success", "perform", "kitchen", "address", "culture", "trouble", "capital", "popular", "produce",
            "situation", "level", "image", "itself", "nature", "likely", "office", "federal", "couple", "social",
            "question", "business", "anything", "decision", "building", "southern", "computer", "hospital", "security", "personal",
            "industry", "interest", "activity", "position", "practice", "evidence", "describe", "director", "response", "campaign",
            "material", "daughter", "congress", "analysis", "movement", "physical", "behavior", "increase", "standard", "remember",
            "consider", "actually", "learning", "research", "military", "resource", "language", "specific", "everyone", "training"
        ];

        const RANKS = [
            { name: "Bronze", minRP: 0, color: "var(--bronze)", baseWPM: 25 },
            { name: "Silver", minRP: 500, color: "var(--silver)", baseWPM: 45 },
            { name: "Gold", minRP: 1000, color: "var(--gold)", baseWPM: 65 },
            { name: "Platinum", minRP: 1500, color: "var(--platinum)", baseWPM: 85 },
            { name: "Diamond", minRP: 2000, color: "var(--diamond)", baseWPM: 105 }
        ];

        // --- 2. State Management ---
        let currentWords = [];
        let currentIndex = 0;
        let startTime = null;
        let timerInterval = null;
        let gameActive = false;
        let totalKeystrokes = 0;
        let totalMistakes = 0;
        
        let bots = [];
        let botTimers = [];

        // Persistent Data
        let userRP = null; // null implies placement match needed

        // --- 3. Logic ---

        function loadUserData() {
            const storedRP = localStorage.getItem('focusType_RP');
            if (storedRP !== null) {
                userRP = parseInt(storedRP, 10);
            } else {
                userRP = null; // Trigger Placement Mode
            }
            updateRankDisplay();
        }

        function getRankInfo(rp) {
            if (rp === null) return { name: "Placement", color: "#999", next: 0 };
            for (let i = RANKS.length - 1; i >= 0; i--) {
                if (rp >= RANKS[i].minRP) {
                    const nextRank = RANKS[i+1] ? RANKS[i+1].minRP : "MAX";
                    return { ...RANKS[i], next: nextRank };
                }
            }
            return RANKS[0];
        }

        function updateRankDisplay() {
            const rank = getRankInfo(userRP);
            const iconEl = document.getElementById('rank-icon');
            const nameEl = document.getElementById('rank-name');
            const detailEl = document.getElementById('rank-details');

            if (userRP === null) {
                iconEl.style.background = "#555";
                iconEl.innerText = "?";
                nameEl.innerText = "PLACEMENT MATCH";
                nameEl.style.color = "#555";
                detailEl.innerText = "Play your first game to determine rank.";
            } else {
                iconEl.style.background = rank.color;
                iconEl.innerText = rank.name[0];
                nameEl.innerText = rank.name;
                nameEl.style.color = rank.color;
                detailEl.innerText = `${userRP} RP` + (rank.next !== "MAX" ? ` / ${rank.next} for Promotion` : " (Max Rank)");
            }
        }

        function shuffle(array) {
            const arr = [...array];
            for (let i = arr.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [arr[i], arr[j]] = [arr[j], arr[i]];
            }
            return arr;
        }

        // --- Game Lifecycle ---

        function initGame() {
            loadUserData();
            
            currentWords = shuffle(wordPool).slice(0, SESSION_LENGTH);
            currentIndex = 0;
            startTime = null;
            totalKeystrokes = 0;
            totalMistakes = 0;
            gameActive = false;
            if(timerInterval) clearInterval(timerInterval);

            // UI Reset
            document.getElementById('type-input').value = '';
            document.getElementById('type-input').disabled = false;
            document.getElementById('type-input').focus();
            document.getElementById('type-input').classList.remove('input-error');
            document.getElementById('results-modal').classList.remove('visible');
            document.getElementById('progress-text').innerText = `0 / ${SESSION_LENGTH}`;
            document.getElementById('timer-text').innerText = "00:00";
            
            // Render Words
            const wb = document.getElementById('word-box');
            wb.innerHTML = '';
            currentWords.forEach((w, i) => {
                const s = document.createElement('span');
                s.className = i === 0 ? 'word active' : 'word';
                s.innerText = w;
                wb.appendChild(s);
            });
            wb.scrollTop = 0;

            // Setup Bots
            setupBots();
        }

        function setupBots() {
            botTimers.forEach(t => clearTimeout(t));
            botTimers = [];
            
            // Reset bars
            ['user', 'bot1', 'bot2', 'bot3'].forEach(k => {
                document.getElementById(`prog-${k}`).style.width = '0%';
            });

            let botSpeeds = [];
            let labels = [];

            if (userRP === null) {
                // PLACEMENT MODE: Fixed benchmarks
                botSpeeds = [30, 50, 70]; 
                labels = ["Novice", "Average", "Skilled"];
            } else {
                // RANKED MODE: Based on Rank Points
                // Formula: Target WPM = 20 + (RP / 25)
                const ladderWPM = 20 + (userRP / 25);
                
                // Gatekeeper (0.85x), Rival (1.0x), Smurf (1.15x)
                botSpeeds = [
                    Math.floor(ladderWPM * 0.85), 
                    Math.floor(ladderWPM * 1.0), 
                    Math.floor(ladderWPM * 1.15)
                ];
                labels = ["Gatekeeper", "Rival", "Smurf"];
            }

            bots = botSpeeds.map((wpm, i) => ({
                id: `bot${i+1}`,
                element: document.getElementById(`prog-bot${i+1}`),
                wpm: Math.max(10, wpm), // Min 10 wpm
                progress: 0,
                finished: false
            }));

            // Update labels
            labels.forEach((lbl, i) => {
                document.getElementById(`label-bot${i+1}`).innerText = `${lbl} (${bots[i].wpm} wpm)`;
            });
        }

        function startBots() {
            bots.forEach((bot, i) => scheduleBotWord(i));
        }

        function scheduleBotWord(botIndex) {
            if (!gameActive) return;
            const bot = bots[botIndex];
            
            if (bot.progress >= SESSION_LENGTH) {
                bot.finished = true;
                return;
            }

            // Nonlinear Logic
            let baseDelay = 60000 / bot.wpm;
            // Variance: 0.7x ~ 1.3x speed per word
            let variance = (Math.random() * 0.6) + 0.7; 
            let actualDelay = baseDelay * variance;

            // Stumble: 10% chance to pause 1.5s
            if (Math.random() < 0.10) actualDelay += 1500;

            const tid = setTimeout(() => {
                if (!gameActive) return;
                bot.progress++;
                bot.element.style.width = `${(bot.progress / SESSION_LENGTH)*100}%`;
                scheduleBotWord(botIndex);
            }, actualDelay);
            
            botTimers.push(tid);
        }

        // --- Inputs ---

        const inputEl = document.getElementById('type-input');
        
        inputEl.addEventListener('input', (e) => {
            if (!startTime && e.target.value.length > 0) {
                gameActive = true;
                startTime = new Date();
                timerInterval = setInterval(() => {
                    const diff = Math.floor((new Date() - startTime) / 1000);
                    const m = Math.floor(diff/60).toString().padStart(2,'0');
                    const s = (diff%60).toString().padStart(2,'0');
                    document.getElementById('timer-text').innerText = `${m}:${s}`;
                }, 1000);
                startBots();
            }

            const typed = e.target.value;
            const target = currentWords[currentIndex];
            totalKeystrokes++;

            if (target.startsWith(typed.trim())) {
                inputEl.classList.remove('input-error');
            } else {
                inputEl.classList.add('input-error');
                totalMistakes++;
            }
        });

        inputEl.addEventListener('keydown', (e) => {
            if (e.code === 'Space') {
                e.preventDefault();
                if (!gameActive) return;

                const val = inputEl.value.trim();
                const target = currentWords[currentIndex];
                const spans = document.querySelectorAll('.word');

                if (val.length > 0) {
                    if (val === target) {
                        spans[currentIndex].classList.add('correct');
                    } else {
                        spans[currentIndex].classList.add('incorrect');
                    }
                    spans[currentIndex].classList.remove('active');

                    currentIndex++;
                    document.getElementById('prog-user').style.width = `${(currentIndex/SESSION_LENGTH)*100}%`;
                    document.getElementById('progress-text').innerText = `${currentIndex} / ${SESSION_LENGTH}`;
                    
                    inputEl.value = '';
                    inputEl.classList.remove('input-error');

                    if (currentIndex >= SESSION_LENGTH) {
                        finishGame();
                    } else {
                        spans[currentIndex].classList.add('active');
                        spans[currentIndex].scrollIntoView({ behavior: "smooth", block: "center" });
                    }
                }
            }
        });

        // --- Finish & Calculations ---

        function finishGame() {
            gameActive = false;
            clearInterval(timerInterval);
            botTimers.forEach(t => clearTimeout(t));
            inputEl.disabled = true;

            const endTime = new Date();
            const minutes = (endTime - startTime) / 60000;
            const totalChars = currentWords.join('').length + SESSION_LENGTH;
            const wpm = Math.round((totalChars / 5) / minutes);
            const accuracy = totalKeystrokes > 0 ? Math.round(((totalKeystrokes - totalMistakes)/totalKeystrokes)*100) : 0;

            // Determine Rank
            let place = 1;
            bots.forEach(b => { if (b.progress >= SESSION_LENGTH) place++; });

            processResults(wpm, accuracy, place);
        }

        function processResults(wpm, accuracy, place) {
            const titleEl = document.getElementById('res-title');
            const subEl = document.getElementById('res-sub');
            const rpChangeEl = document.getElementById('res-rp-change');

            // UI Stats
            document.getElementById('res-wpm').innerText = wpm;
            document.getElementById('res-acc').innerText = accuracy + "%";
            document.getElementById('res-rank').innerText = place;

            // LOGIC BRANCH: Placement vs Ranked
            if (userRP === null) {
                // === PLACEMENT MATCH LOGIC ===
                // Rule: WPM * 0.8 -> Corresponding Rank Points
                const calibratedWPM = Math.max(10, Math.floor(wpm * 0.8));
                
                // Formula Inverse: RP = (WPM - 20) * 25
                // Example: 60 wpm -> 48 calibrated -> (48-20)*25 = 700 RP (Silver)
                let newRP = Math.floor((calibratedWPM - 20) * 25);
                if (newRP < 0) newRP = 0;

                userRP = newRP;
                localStorage.setItem('focusType_RP', userRP);

                titleEl.innerText = "Placement Complete!";
                subEl.innerText = `Calibrated at ${calibratedWPM} WPM (80% of performance)`;
                rpChangeEl.innerHTML = `<span style="color:var(--highlight); font-size:1.5rem;">Assigned: ${getRankInfo(userRP).name} (${userRP} RP)</span>`;
            
            } else {
                // === RANKED MATCH LOGIC ===
                let change = 0;
                if (place === 1) change = 30;
                else if (place === 2) change = 10;
                else if (place === 3) change = -10;
                else change = -30;

                // Apply Change
                userRP += change;
                if (userRP < 0) userRP = 0; // Floor
                localStorage.setItem('focusType_RP', userRP);

                // UI Text
                titleEl.innerText = place <= 2 ? "Victory!" : "Defeat";
                titleEl.style.color = place <= 2 ? "var(--correct)" : "var(--error)";
                subEl.innerText = place <= 2 ? "Well done, climbing the ladder." : "Keep practicing to keep up.";

                const sign = change > 0 ? "+" : "";
                const colorClass = change >= 0 ? "rp-plus" : "rp-minus";
                rpChangeEl.innerHTML = `<span class="${colorClass}">${sign}${change} RP</span>`;
            }

            document.getElementById('results-modal').classList.add('visible');
            updateRankDisplay();
        }

        function resetData() {
            if(confirm("Reset all rank data? You will play a placement match next.")) {
                localStorage.removeItem('focusType_RP');
                location.reload();
            }
        }

        // Start
        window.onload = initGame;

    </script>
</body>
</html>
